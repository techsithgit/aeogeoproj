{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///Users/hemilpatel/Documents/dev/codex/aeogeoproj/lib/analysis/engine.ts"],"sourcesContent":["import crypto from \"crypto\";\nimport {\n  Analysis,\n  AnalysisContext,\n  AnalysisScoring,\n  AnalysisVersion,\n  DiagnosisReason,\n  PromptCluster,\n  RecommendedFix,\n} from \"./types\";\n\nconst ANALYSIS_VERSION: AnalysisVersion = \"v1\";\n\ntype TopicSignals = {\n  normalized: string;\n  lower: string;\n  words: string[];\n  hasQuestionWord: boolean;\n  hasQuestionMark: boolean;\n  hasComparison: boolean;\n  hasBestSuperlative: boolean;\n  hasTransactionalCue: boolean;\n  hasGeoCue: boolean;\n};\n\nconst questionWords = [\"who\", \"what\", \"when\", \"where\", \"why\", \"how\"];\nconst comparisonWords = [\"vs\", \"versus\", \"compare\", \"comparison\", \"against\"];\nconst superlatives = [\"best\", \"top\", \"leading\", \"most\"];\nconst transactionalWords = [\"buy\", \"price\", \"pricing\", \"cost\", \"deal\", \"order\", \"book\"];\nconst geoWords = [\"near me\", \"in \", \"at \", \"around\", \"closest\", \"local\"];\n\nfunction extractSignals(topic: string): TopicSignals {\n  const normalized = topic.trim();\n  const lower = normalized.toLowerCase();\n  const words = normalized.split(/\\s+/).filter(Boolean);\n  const hasQuestionWord = words.some((w) => questionWords.includes(w.toLowerCase()));\n  const hasQuestionMark = normalized.includes(\"?\");\n  const hasComparison = comparisonWords.some((w) => lower.includes(w));\n  const hasBestSuperlative = superlatives.some((w) => lower.includes(w));\n  const hasTransactionalCue = transactionalWords.some((w) => lower.includes(w));\n  const hasGeoCue = geoWords.some((w) => lower.includes(w));\n\n  return {\n    normalized,\n    lower,\n    words,\n    hasQuestionWord,\n    hasQuestionMark,\n    hasComparison,\n    hasBestSuperlative,\n    hasTransactionalCue,\n    hasGeoCue,\n  };\n}\n\nfunction deriveIntent(signals: TopicSignals): \"informational\" | \"navigational\" | \"transactional\" | \"ambiguous\" {\n  if (signals.hasTransactionalCue) {\n    return \"transactional\";\n  }\n  if (signals.hasGeoCue) {\n    return signals.hasQuestionWord ? \"navigational\" : \"navigational\";\n  }\n  if (signals.hasQuestionWord || signals.hasComparison || signals.hasBestSuperlative) {\n    return \"informational\";\n  }\n  return \"ambiguous\";\n}\n\nfunction buildPromptClusters(signals: TopicSignals, context: AnalysisContext): PromptCluster[] {\n  const clusters: PromptCluster[] = [];\n\n  clusters.push({\n    label: \"specificity\",\n    signals: [\n      signals.words.length >= 4 ? \"has multi-word intent\" : \"ultra-short topic\",\n      signals.hasComparison ? \"comparison cue\" : \"no comparison cue\",\n      signals.hasBestSuperlative ? \"seeks ranked guidance\" : \"no ranking cue\",\n    ],\n  });\n\n  clusters.push({\n    label: \"context\",\n    signals: [\n      context.location ? `location: ${context.location}` : \"location missing\",\n      context.industry ? `industry: ${context.industry}` : \"industry missing\",\n      signals.hasGeoCue ? \"geo phrasing in topic\" : \"no geo phrasing in topic\",\n    ],\n  });\n\n  clusters.push({\n    label: \"actionability\",\n    signals: [\n      signals.hasTransactionalCue ? \"action/transaction cue\" : \"no action cue\",\n      signals.hasQuestionMark || signals.hasQuestionWord ? \"explicit ask\" : \"implicit ask\",\n    ],\n  });\n\n  return clusters;\n}\n\nfunction scoreClarity(signals: TopicSignals): number {\n  let score = 78;\n  if (signals.words.length < 3) score -= 25;\n  if (signals.words.length >= 6 && signals.words.length <= 12) score += 8;\n  if (!signals.hasQuestionMark && !signals.hasQuestionWord) score -= 12;\n  if (signals.hasComparison || signals.hasBestSuperlative) score += 6;\n  if (signals.hasTransactionalCue) score += 6;\n  if (signals.hasGeoCue && signals.words.length < 4) score -= 4;\n\n  return Math.min(100, Math.max(0, score));\n}\n\nfunction deriveAnswerPresence(signals: TopicSignals): \"missing\" | \"partial\" | \"clear\" {\n  if (signals.hasQuestionWord || signals.hasQuestionMark) return \"clear\";\n  if (signals.hasTransactionalCue || signals.hasComparison || signals.hasBestSuperlative) return \"partial\";\n  if (signals.hasGeoCue) return \"partial\";\n  return \"missing\";\n}\n\nfunction gatherStructureIssues(signals: TopicSignals, context: AnalysisContext): string[] {\n  const issues: string[] = [];\n  if (!signals.hasQuestionWord && !signals.hasQuestionMark) {\n    issues.push(\"Topic is not framed as a direct ask, so the AI must infer the question.\");\n  }\n  if (signals.words.length < 4) {\n    issues.push(\"Topic is very short, which weakens clarity of the expected answer.\");\n  }\n  if (signals.hasComparison && !signals.hasBestSuperlative) {\n    issues.push(\"Comparison prompt lacks criteria for how to decide a winner.\");\n  }\n  if (!context.location && signals.hasGeoCue) {\n    issues.push(\"Geo phrasing is present without an explicit location to anchor the answer.\");\n  }\n  if (!context.industry && !signals.hasTransactionalCue) {\n    issues.push(\"No industry or domain anchor is provided.\");\n  }\n  return issues;\n}\n\nfunction buildReasons(signals: TopicSignals, context: AnalysisContext): DiagnosisReason[] {\n  const reasons: DiagnosisReason[] = [];\n  const intent = deriveIntent(signals);\n\n  reasons.push({\n    id: \"reason_1\",\n    title: \"Ambiguous intent\",\n    detail:\n      intent === \"ambiguous\"\n        ? \"The topic does not declare whether the expected answer is informational, navigational, or transactional.\"\n        : \"The topic leaves room for multiple interpretations, so an AI answer may not match the user's real goal.\",\n    severity: intent === \"ambiguous\" ? \"high\" : \"medium\",\n    rank: 1,\n  });\n\n  reasons.push({\n    id: \"reason_2\",\n    title: \"Missing context\",\n    detail:\n      context.location || context.industry\n        ? \"Context is partial; AI still lacks clear guardrails to ground the answer.\"\n        : \"No location or industry anchor is provided, so the answer will stay generic and less trustworthy.\",\n    severity: context.location || context.industry ? \"medium\" : \"high\",\n    rank: 2,\n  });\n\n  reasons.push({\n    id: \"reason_3\",\n    title: \"Unstated answer format\",\n    detail:\n      signals.hasQuestionWord || signals.hasQuestionMark\n        ? \"The question is asked, but the expected format (checklist, steps, ranked list) is not specified.\"\n        : \"The topic is not phrased as a question, so the AI must guess the answer shape.\",\n    severity: signals.hasQuestionWord || signals.hasQuestionMark ? \"medium\" : \"high\",\n    rank: 3,\n  });\n\n  if (!signals.hasTransactionalCue && !signals.hasBestSuperlative) {\n    reasons.push({\n      id: \"reason_4\",\n      title: \"Weak authority signals\",\n      detail: \"There are no qualifiers (e.g., timeframe, data points, audience) that would signal reliability.\",\n      severity: \"low\",\n      rank: 4,\n    });\n  }\n\n  return reasons.slice(0, 5);\n}\n\nfunction buildFixes(reasons: DiagnosisReason[]): RecommendedFix[] {\n  const fixes: RecommendedFix[] = [];\n\n  const reasonIds = new Set(reasons.map((r) => r.id));\n\n  if (reasonIds.has(\"reason_1\")) {\n    fixes.push({\n      id: \"fix_1\",\n      description: \"Rewrite the topic to name the exact action or decision you want (e.g., 'How to choose X for Y outcome').\",\n      why_it_matters: \"Explicit intent lets the AI choose a fitting reasoning path instead of guessing.\",\n      maps_to_reason_ids: [\"reason_1\"],\n    });\n  }\n\n  if (reasonIds.has(\"reason_2\")) {\n    fixes.push({\n      id: \"fix_2\",\n      description: \"Add location or industry qualifiers so the answer uses relevant constraints and examples.\",\n      why_it_matters: \"Grounding the request reduces generic output and improves trustworthiness.\",\n      maps_to_reason_ids: [\"reason_2\"],\n    });\n  }\n\n  if (reasonIds.has(\"reason_3\")) {\n    fixes.push({\n      id: \"fix_3\",\n      description: \"State the desired answer format (checklist, steps, ranked picks) and the decision criteria.\",\n      why_it_matters: \"Format cues help the AI organize the response and avoid irrelevant details.\",\n      maps_to_reason_ids: [\"reason_3\"],\n    });\n  }\n\n  if (reasonIds.has(\"reason_4\")) {\n    fixes.push({\n      id: \"fix_4\",\n      description: \"Include a grounding signal such as timeframe, audience, or data proof you expect the AI to cite.\",\n      why_it_matters: \"Authority cues signal that the answer should be supported, not speculative.\",\n      maps_to_reason_ids: [\"reason_4\"],\n    });\n  }\n\n  return fixes;\n}\n\nfunction scoreAnalysis(reasons: DiagnosisReason[], clarityScore: number): AnalysisScoring {\n  let score = 85;\n  const explanation: string[] = [];\n\n  reasons.forEach((reason) => {\n    const penalty = reason.severity === \"high\" ? 18 : reason.severity === \"medium\" ? 10 : 6;\n    score -= penalty;\n    explanation.push(`${reason.title} reduces confidence because ${reason.detail}`);\n  });\n\n  score += Math.round((clarityScore - 60) / 4);\n\n  return {\n    aeo_score: Math.max(0, Math.min(100, score)),\n    score_explanations: explanation.map((message, idx) => ({\n      id: `score_${idx + 1}`,\n      message,\n    })),\n  };\n}\n\nexport function generateAnalysis(id: string, topic: string, context: AnalysisContext = {}): Analysis {\n  const signals = extractSignals(topic);\n  const intent = deriveIntent(signals);\n  const promptClusters = buildPromptClusters(signals, context);\n  const clarity = scoreClarity(signals);\n  const answerPresence = deriveAnswerPresence(signals);\n  const structureIssues = gatherStructureIssues(signals, context);\n  const reasons = buildReasons(signals, context);\n  const fixes = buildFixes(reasons);\n  const scoring = scoreAnalysis(reasons, clarity);\n  const now = new Date().toISOString();\n\n  return {\n    id,\n    analysis_version: ANALYSIS_VERSION,\n    created_at: now,\n    updated_at: now,\n    source: {\n      type: \"topic\",\n      value: topic,\n    },\n    context,\n    prompt_intelligence: {\n      dominant_intent: intent,\n      intent_mismatch:\n        intent === \"ambiguous\"\n          ? \"AI cannot tell whether the ask is informational, navigational, or transactional.\"\n          : structureIssues.find((issue) => issue.toLowerCase().includes(\"not framed\"))\n          ? \"The ask is implied rather than explicit, so the AI may answer the wrong question.\"\n          : null,\n      prompt_clusters: promptClusters,\n    },\n    aeo: {\n      answer_clarity_score: clarity,\n      answer_presence: answerPresence,\n      structure_issues: structureIssues,\n    },\n    diagnosis: {\n      blocking_reasons: reasons,\n    },\n    fixes: {\n      recommended_fixes: fixes,\n    },\n    scoring,\n  };\n}\n\nexport function createAnalysisId(): string {\n  return crypto.randomUUID();\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 351, "column": 0}, "map": {"version":3,"sources":["file:///Users/hemilpatel/Documents/dev/codex/aeogeoproj/lib/persistence/fileStore.ts"],"sourcesContent":["import fs from \"fs\";\nimport path from \"path\";\nimport { Analysis, AnalysisContext, AnalysisRecord, AnalysisStatus } from \"../analysis/types\";\nimport { AnalysisStore } from \"./types\";\n\nconst primaryStorePath =\n  process.env.ANALYSIS_STORE_PATH ||\n  path.resolve(process.cwd(), \".next\", \"analysis-store.json\");\n\nconst fallbackPaths = [\n  primaryStorePath,\n  path.resolve(process.cwd(), \"analysis-store.json\"),\n  \"/tmp/analysis-store.json\",\n];\n\ntype StoreState = {\n  memory: Map<string, AnalysisRecord>;\n};\n\nconst globalStore: StoreState =\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (globalThis as any).__analysisHybridStore ??\n  {\n    memory: new Map<string, AnalysisRecord>(),\n  };\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(globalThis as any).__analysisHybridStore = globalStore;\n\nfunction ensureStoreDir(filePath: string) {\n  const dir = path.dirname(filePath);\n  if (!fs.existsSync(dir)) {\n    fs.mkdirSync(dir, { recursive: true });\n  }\n}\n\nfunction loadAllStores(): Record<string, AnalysisRecord> {\n  const merged: Record<string, AnalysisRecord> = {};\n  for (const candidate of fallbackPaths) {\n    try {\n      const contents = fs.readFileSync(candidate, \"utf-8\");\n      const parsed = JSON.parse(contents) as Record<string, AnalysisRecord>;\n      Object.assign(merged, parsed);\n    } catch {\n      // ignore missing/invalid files\n    }\n  }\n  return merged;\n}\n\nfunction persistStore(data: Record<string, AnalysisRecord>) {\n  ensureStoreDir(primaryStorePath);\n  fs.writeFileSync(primaryStorePath, JSON.stringify(data, null, 2), \"utf-8\");\n}\n\nfunction syncMemoryFromDisk() {\n  const data = loadAllStores();\n  Object.entries(data).forEach(([id, record]) => {\n    globalStore.memory.set(id, record);\n  });\n}\n\nsyncMemoryFromDisk();\n\nexport class FileAnalysisStore implements AnalysisStore {\n  async createRecord(id: string, topic: string, context: AnalysisContext, status: AnalysisStatus): Promise<AnalysisRecord> {\n    const now = new Date().toISOString();\n    const record: AnalysisRecord = {\n      id,\n      status,\n      created_at: now,\n      updated_at: now,\n      request: {\n        topic,\n        context,\n      },\n    };\n    globalStore.memory.set(id, record);\n    const merged = { ...loadAllStores(), [id]: record };\n    persistStore(merged);\n    return record;\n  }\n\n  async saveAnalysis(id: string, analysis: Analysis, status: AnalysisStatus = \"complete\"): Promise<AnalysisRecord | undefined> {\n    const existing = await this.getRecord(id);\n    if (!existing) return undefined;\n    const updated: AnalysisRecord = {\n      ...existing,\n      analysis,\n      status,\n      updated_at: new Date().toISOString(),\n    };\n    globalStore.memory.set(id, updated);\n    const merged = { ...loadAllStores(), [id]: updated };\n    persistStore(merged);\n    return updated;\n  }\n\n  async markFailed(id: string, error: string): Promise<AnalysisRecord | undefined> {\n    const existing = await this.getRecord(id);\n    if (!existing) return undefined;\n    const updated: AnalysisRecord = {\n      ...existing,\n      status: \"failed\",\n      error,\n      updated_at: new Date().toISOString(),\n    };\n    globalStore.memory.set(id, updated);\n    const merged = { ...loadAllStores(), [id]: updated };\n    persistStore(merged);\n    return updated;\n  }\n\n  async getRecord(id: string): Promise<AnalysisRecord | undefined> {\n    const fromMemory = globalStore.memory.get(id);\n    if (fromMemory) return fromMemory;\n    const all = loadAllStores();\n    const fromDisk = all[id];\n    if (fromDisk) {\n      globalStore.memory.set(id, fromDisk);\n    }\n    return fromDisk;\n  }\n}\n\nexport const fileAnalysisStore = new FileAnalysisStore();\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 482, "column": 0}, "map": {"version":3,"sources":["file:///Users/hemilpatel/Documents/dev/codex/aeogeoproj/lib/persistence/kvStore.ts"],"sourcesContent":["import { kv } from \"@vercel/kv\";\nimport { Analysis, AnalysisContext, AnalysisRecord, AnalysisStatus } from \"../analysis/types\";\nimport { AnalysisStore } from \"./types\";\n\nconst KV_PREFIX = process.env.ANALYSIS_KV_PREFIX || \"analysis\";\n\nfunction key(id: string) {\n  return `${KV_PREFIX}:${id}`;\n}\n\nexport class VercelKVStore implements AnalysisStore {\n  async createRecord(id: string, topic: string, context: AnalysisContext, status: AnalysisStatus): Promise<AnalysisRecord> {\n    const now = new Date().toISOString();\n    const record: AnalysisRecord = {\n      id,\n      status,\n      created_at: now,\n      updated_at: now,\n      request: { topic, context },\n    };\n    await kv.set(key(id), record);\n    return record;\n  }\n\n  async saveAnalysis(id: string, analysis: Analysis, status: AnalysisStatus = \"complete\"): Promise<AnalysisRecord | undefined> {\n    const existing = await this.getRecord(id);\n    if (!existing) return undefined;\n    const updated: AnalysisRecord = {\n      ...existing,\n      analysis,\n      status,\n      updated_at: new Date().toISOString(),\n    };\n    await kv.set(key(id), updated);\n    return updated;\n  }\n\n  async markFailed(id: string, error: string): Promise<AnalysisRecord | undefined> {\n    const existing = await this.getRecord(id);\n    if (!existing) return undefined;\n    const updated: AnalysisRecord = {\n      ...existing,\n      status: \"failed\",\n      error,\n      updated_at: new Date().toISOString(),\n    };\n    await kv.set(key(id), updated);\n    return updated;\n  }\n\n  async getRecord(id: string): Promise<AnalysisRecord | undefined> {\n    const record = await kv.get<AnalysisRecord>(key(id));\n    return record ?? undefined;\n  }\n}\n\nexport const kvAnalysisStore = new VercelKVStore();\n"],"names":[],"mappings":";;;;;;AAAA;;AAIA,MAAM,YAAY,QAAQ,GAAG,CAAC,kBAAkB,IAAI;AAEpD,SAAS,IAAI,EAAU;IACrB,OAAO,GAAG,UAAU,CAAC,EAAE,IAAI;AAC7B;AAEO,MAAM;IACX,MAAM,aAAa,EAAU,EAAE,KAAa,EAAE,OAAwB,EAAE,MAAsB,EAA2B;QACvH,MAAM,MAAM,IAAI,OAAO,WAAW;QAClC,MAAM,SAAyB;YAC7B;YACA;YACA,YAAY;YACZ,YAAY;YACZ,SAAS;gBAAE;gBAAO;YAAQ;QAC5B;QACA,MAAM,uJAAE,CAAC,GAAG,CAAC,IAAI,KAAK;QACtB,OAAO;IACT;IAEA,MAAM,aAAa,EAAU,EAAE,QAAkB,EAAE,SAAyB,UAAU,EAAuC;QAC3H,MAAM,WAAW,MAAM,IAAI,CAAC,SAAS,CAAC;QACtC,IAAI,CAAC,UAAU,OAAO;QACtB,MAAM,UAA0B;YAC9B,GAAG,QAAQ;YACX;YACA;YACA,YAAY,IAAI,OAAO,WAAW;QACpC;QACA,MAAM,uJAAE,CAAC,GAAG,CAAC,IAAI,KAAK;QACtB,OAAO;IACT;IAEA,MAAM,WAAW,EAAU,EAAE,KAAa,EAAuC;QAC/E,MAAM,WAAW,MAAM,IAAI,CAAC,SAAS,CAAC;QACtC,IAAI,CAAC,UAAU,OAAO;QACtB,MAAM,UAA0B;YAC9B,GAAG,QAAQ;YACX,QAAQ;YACR;YACA,YAAY,IAAI,OAAO,WAAW;QACpC;QACA,MAAM,uJAAE,CAAC,GAAG,CAAC,IAAI,KAAK;QACtB,OAAO;IACT;IAEA,MAAM,UAAU,EAAU,EAAuC;QAC/D,MAAM,SAAS,MAAM,uJAAE,CAAC,GAAG,CAAiB,IAAI;QAChD,OAAO,UAAU;IACnB;AACF;AAEO,MAAM,kBAAkB,IAAI"}},
    {"offset": {"line": 544, "column": 0}, "map": {"version":3,"sources":["file:///Users/hemilpatel/Documents/dev/codex/aeogeoproj/lib/persistence/index.ts"],"sourcesContent":["import { fileAnalysisStore } from \"./fileStore\";\nimport { kvAnalysisStore } from \"./kvStore\";\nimport { AnalysisStore } from \"./types\";\n\nconst provider = process.env.ANALYSIS_STORE_PROVIDER || \"file\";\n\nexport function getAnalysisStore(): AnalysisStore {\n  if (provider === \"kv\") {\n    return kvAnalysisStore;\n  }\n  return fileAnalysisStore;\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAGA,MAAM,WAAW,QAAQ,GAAG,CAAC,uBAAuB,IAAI;AAEjD,SAAS;IACd,IAAI,aAAa,MAAM;QACrB,OAAO,kJAAe;IACxB;IACA,OAAO,sJAAiB;AAC1B"}},
    {"offset": {"line": 563, "column": 0}, "map": {"version":3,"sources":["file:///Users/hemilpatel/Documents/dev/codex/aeogeoproj/app/api/analyses/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\nimport { createAnalysisId, generateAnalysis } from \"@/lib/analysis/engine\";\nimport { getAnalysisStore } from \"@/lib/persistence/index\";\nimport { AnalysisContext } from \"@/lib/analysis/types\";\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json();\n    const topic = typeof body?.topic === \"string\" ? body.topic.trim() : \"\";\n    if (!topic) {\n      return NextResponse.json({ error: \"topic is required\" }, { status: 400 });\n    }\n\n    const context: AnalysisContext = body?.context ?? {};\n    const id = createAnalysisId();\n\n    const store = getAnalysisStore();\n\n    await store.createRecord(id, topic, context, \"processing\");\n    const analysis = generateAnalysis(id, topic, context);\n    await store.saveAnalysis(id, analysis, \"complete\");\n\n    return NextResponse.json({ analysis_id: id, status: \"complete\", analysis });\n  } catch (_error) {\n    return NextResponse.json({ error: \"Unable to create analysis\" }, { status: 500 });\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAGO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,QAAQ,OAAO,MAAM,UAAU,WAAW,KAAK,KAAK,CAAC,IAAI,KAAK;QACpE,IAAI,CAAC,OAAO;YACV,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAoB,GAAG;gBAAE,QAAQ;YAAI;QACzE;QAEA,MAAM,UAA2B,MAAM,WAAW,CAAC;QACnD,MAAM,KAAK,IAAA,+IAAgB;QAE3B,MAAM,QAAQ,IAAA,iJAAgB;QAE9B,MAAM,MAAM,YAAY,CAAC,IAAI,OAAO,SAAS;QAC7C,MAAM,WAAW,IAAA,+IAAgB,EAAC,IAAI,OAAO;QAC7C,MAAM,MAAM,YAAY,CAAC,IAAI,UAAU;QAEvC,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,aAAa;YAAI,QAAQ;YAAY;QAAS;IAC3E,EAAE,OAAO,QAAQ;QACf,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAA4B,GAAG;YAAE,QAAQ;QAAI;IACjF;AACF"}}]
}