{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///Users/hemilpatel/Documents/dev/codex/aeogeoproj/lib/persistence/fileStore.ts"],"sourcesContent":["import fs from \"fs\";\nimport path from \"path\";\nimport { Analysis, AnalysisContext, AnalysisRecord, AnalysisStatus } from \"../analysis/types\";\nimport { AnalysisStore } from \"./types\";\n\nconst primaryStorePath =\n  process.env.ANALYSIS_STORE_PATH ||\n  path.resolve(process.cwd(), \".next\", \"analysis-store.json\");\n\nconst fallbackPaths = [\n  primaryStorePath,\n  path.resolve(process.cwd(), \"analysis-store.json\"),\n  \"/tmp/analysis-store.json\",\n];\n\ntype StoreState = {\n  memory: Map<string, AnalysisRecord>;\n};\n\nconst globalStore: StoreState =\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (globalThis as any).__analysisHybridStore ??\n  {\n    memory: new Map<string, AnalysisRecord>(),\n  };\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(globalThis as any).__analysisHybridStore = globalStore;\n\nfunction ensureStoreDir(filePath: string) {\n  const dir = path.dirname(filePath);\n  if (!fs.existsSync(dir)) {\n    fs.mkdirSync(dir, { recursive: true });\n  }\n}\n\nfunction loadAllStores(): Record<string, AnalysisRecord> {\n  const merged: Record<string, AnalysisRecord> = {};\n  for (const candidate of fallbackPaths) {\n    try {\n      const contents = fs.readFileSync(candidate, \"utf-8\");\n      const parsed = JSON.parse(contents) as Record<string, AnalysisRecord>;\n      Object.assign(merged, parsed);\n    } catch {\n      // ignore missing/invalid files\n    }\n  }\n  return merged;\n}\n\nfunction persistStore(data: Record<string, AnalysisRecord>) {\n  ensureStoreDir(primaryStorePath);\n  fs.writeFileSync(primaryStorePath, JSON.stringify(data, null, 2), \"utf-8\");\n}\n\nfunction syncMemoryFromDisk() {\n  const data = loadAllStores();\n  Object.entries(data).forEach(([id, record]) => {\n    globalStore.memory.set(id, record);\n  });\n}\n\nsyncMemoryFromDisk();\n\nexport class FileAnalysisStore implements AnalysisStore {\n  async createRecord(id: string, topic: string, context: AnalysisContext, status: AnalysisStatus): Promise<AnalysisRecord> {\n    const now = new Date().toISOString();\n    const record: AnalysisRecord = {\n      id,\n      status,\n      created_at: now,\n      updated_at: now,\n      request: {\n        topic,\n        context,\n      },\n    };\n    globalStore.memory.set(id, record);\n    const merged = { ...loadAllStores(), [id]: record };\n    persistStore(merged);\n    return record;\n  }\n\n  async saveAnalysis(id: string, analysis: Analysis, status: AnalysisStatus = \"complete\"): Promise<AnalysisRecord | undefined> {\n    const existing = await this.getRecord(id);\n    if (!existing) return undefined;\n    const updated: AnalysisRecord = {\n      ...existing,\n      analysis,\n      status,\n      updated_at: new Date().toISOString(),\n    };\n    globalStore.memory.set(id, updated);\n    const merged = { ...loadAllStores(), [id]: updated };\n    persistStore(merged);\n    return updated;\n  }\n\n  async markFailed(id: string, error: string): Promise<AnalysisRecord | undefined> {\n    const existing = await this.getRecord(id);\n    if (!existing) return undefined;\n    const updated: AnalysisRecord = {\n      ...existing,\n      status: \"failed\",\n      error,\n      updated_at: new Date().toISOString(),\n    };\n    globalStore.memory.set(id, updated);\n    const merged = { ...loadAllStores(), [id]: updated };\n    persistStore(merged);\n    return updated;\n  }\n\n  async getRecord(id: string): Promise<AnalysisRecord | undefined> {\n    const fromMemory = globalStore.memory.get(id);\n    if (fromMemory) return fromMemory;\n    const all = loadAllStores();\n    const fromDisk = all[id];\n    if (fromDisk) {\n      globalStore.memory.set(id, fromDisk);\n    }\n    return fromDisk;\n  }\n}\n\nexport const fileAnalysisStore = new FileAnalysisStore();\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 189, "column": 0}, "map": {"version":3,"sources":["file:///Users/hemilpatel/Documents/dev/codex/aeogeoproj/lib/persistence/kvStore.ts"],"sourcesContent":["import { kv } from \"@vercel/kv\";\nimport { Analysis, AnalysisContext, AnalysisRecord, AnalysisStatus } from \"../analysis/types\";\nimport { AnalysisStore } from \"./types\";\n\nconst KV_PREFIX = process.env.ANALYSIS_KV_PREFIX || \"analysis\";\n\nfunction key(id: string) {\n  return `${KV_PREFIX}:${id}`;\n}\n\nexport class VercelKVStore implements AnalysisStore {\n  async createRecord(id: string, topic: string, context: AnalysisContext, status: AnalysisStatus): Promise<AnalysisRecord> {\n    const now = new Date().toISOString();\n    const record: AnalysisRecord = {\n      id,\n      status,\n      created_at: now,\n      updated_at: now,\n      request: { topic, context },\n    };\n    await kv.set(key(id), record);\n    return record;\n  }\n\n  async saveAnalysis(id: string, analysis: Analysis, status: AnalysisStatus = \"complete\"): Promise<AnalysisRecord | undefined> {\n    const existing = await this.getRecord(id);\n    if (!existing) return undefined;\n    const updated: AnalysisRecord = {\n      ...existing,\n      analysis,\n      status,\n      updated_at: new Date().toISOString(),\n    };\n    await kv.set(key(id), updated);\n    return updated;\n  }\n\n  async markFailed(id: string, error: string): Promise<AnalysisRecord | undefined> {\n    const existing = await this.getRecord(id);\n    if (!existing) return undefined;\n    const updated: AnalysisRecord = {\n      ...existing,\n      status: \"failed\",\n      error,\n      updated_at: new Date().toISOString(),\n    };\n    await kv.set(key(id), updated);\n    return updated;\n  }\n\n  async getRecord(id: string): Promise<AnalysisRecord | undefined> {\n    const record = await kv.get<AnalysisRecord>(key(id));\n    return record ?? undefined;\n  }\n}\n\nexport const kvAnalysisStore = new VercelKVStore();\n"],"names":[],"mappings":";;;;;;AAAA;;AAIA,MAAM,YAAY,QAAQ,GAAG,CAAC,kBAAkB,IAAI;AAEpD,SAAS,IAAI,EAAU;IACrB,OAAO,GAAG,UAAU,CAAC,EAAE,IAAI;AAC7B;AAEO,MAAM;IACX,MAAM,aAAa,EAAU,EAAE,KAAa,EAAE,OAAwB,EAAE,MAAsB,EAA2B;QACvH,MAAM,MAAM,IAAI,OAAO,WAAW;QAClC,MAAM,SAAyB;YAC7B;YACA;YACA,YAAY;YACZ,YAAY;YACZ,SAAS;gBAAE;gBAAO;YAAQ;QAC5B;QACA,MAAM,uJAAE,CAAC,GAAG,CAAC,IAAI,KAAK;QACtB,OAAO;IACT;IAEA,MAAM,aAAa,EAAU,EAAE,QAAkB,EAAE,SAAyB,UAAU,EAAuC;QAC3H,MAAM,WAAW,MAAM,IAAI,CAAC,SAAS,CAAC;QACtC,IAAI,CAAC,UAAU,OAAO;QACtB,MAAM,UAA0B;YAC9B,GAAG,QAAQ;YACX;YACA;YACA,YAAY,IAAI,OAAO,WAAW;QACpC;QACA,MAAM,uJAAE,CAAC,GAAG,CAAC,IAAI,KAAK;QACtB,OAAO;IACT;IAEA,MAAM,WAAW,EAAU,EAAE,KAAa,EAAuC;QAC/E,MAAM,WAAW,MAAM,IAAI,CAAC,SAAS,CAAC;QACtC,IAAI,CAAC,UAAU,OAAO;QACtB,MAAM,UAA0B;YAC9B,GAAG,QAAQ;YACX,QAAQ;YACR;YACA,YAAY,IAAI,OAAO,WAAW;QACpC;QACA,MAAM,uJAAE,CAAC,GAAG,CAAC,IAAI,KAAK;QACtB,OAAO;IACT;IAEA,MAAM,UAAU,EAAU,EAAuC;QAC/D,MAAM,SAAS,MAAM,uJAAE,CAAC,GAAG,CAAiB,IAAI;QAChD,OAAO,UAAU;IACnB;AACF;AAEO,MAAM,kBAAkB,IAAI"}},
    {"offset": {"line": 251, "column": 0}, "map": {"version":3,"sources":["file:///Users/hemilpatel/Documents/dev/codex/aeogeoproj/lib/persistence/index.ts"],"sourcesContent":["import { fileAnalysisStore } from \"./fileStore\";\nimport { kvAnalysisStore } from \"./kvStore\";\nimport { AnalysisStore } from \"./types\";\n\nconst provider = process.env.ANALYSIS_STORE_PROVIDER || \"file\";\n\nexport function getAnalysisStore(): AnalysisStore {\n  if (provider === \"kv\") {\n    return kvAnalysisStore;\n  }\n  return fileAnalysisStore;\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAGA,MAAM,WAAW,QAAQ,GAAG,CAAC,uBAAuB,IAAI;AAEjD,SAAS;IACd,IAAI,aAAa,MAAM;QACrB,OAAO,kJAAe;IACxB;IACA,OAAO,sJAAiB;AAC1B"}},
    {"offset": {"line": 270, "column": 0}, "map": {"version":3,"sources":["file:///Users/hemilpatel/Documents/dev/codex/aeogeoproj/app/api/analyses/%5Banalysis_id%5D/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\nimport { getAnalysisStore } from \"@/lib/persistence\";\n\ntype Params = Promise<{\n  analysis_id: string;\n}>;\n\nexport async function GET(_request: NextRequest, context: { params: Params }) {\n  const { analysis_id } = await context.params;\n  const store = getAnalysisStore();\n  const record = await store.getRecord(analysis_id);\n\n  if (!record) {\n    return NextResponse.json({ error: \"Analysis not found\" }, { status: 404 });\n  }\n\n  return NextResponse.json({\n    analysis_id: record.id,\n    status: record.status,\n    analysis: record.status === \"complete\" ? record.analysis : undefined,\n    error: record.status === \"failed\" ? record.error ?? \"Analysis failed\" : undefined,\n  });\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAMO,eAAe,IAAI,QAAqB,EAAE,OAA2B;IAC1E,MAAM,EAAE,WAAW,EAAE,GAAG,MAAM,QAAQ,MAAM;IAC5C,MAAM,QAAQ,IAAA,iJAAgB;IAC9B,MAAM,SAAS,MAAM,MAAM,SAAS,CAAC;IAErC,IAAI,CAAC,QAAQ;QACX,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAqB,GAAG;YAAE,QAAQ;QAAI;IAC1E;IAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;QACvB,aAAa,OAAO,EAAE;QACtB,QAAQ,OAAO,MAAM;QACrB,UAAU,OAAO,MAAM,KAAK,aAAa,OAAO,QAAQ,GAAG;QAC3D,OAAO,OAAO,MAAM,KAAK,WAAW,OAAO,KAAK,IAAI,oBAAoB;IAC1E;AACF"}}]
}